(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{638:function(r,t,v){"use strict";v.r(t);var a=v(5),_=Object(a.a)({},(function(){var r=this,t=r.$createElement,v=r._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"title"},[r._v("介绍")]),v("p",[r._v("JVM知识点")])]),v("h3",{attrs:{id:"_1-jvm的运行机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-jvm的运行机制"}},[r._v("#")]),r._v(" 1. JVM的运行机制")]),r._v(" "),v("p",[r._v("​\t\tJVM是用于运行Java字节码的虚拟机，包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区、和一个垃圾回收器。JVM运行在操作系统之上，不与硬件设备直接交互。")]),r._v(" "),v("h3",{attrs:{id:"_2-jvm的多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-jvm的多线程"}},[r._v("#")]),r._v(" 2. JVM的多线程")]),r._v(" "),v("h3",{attrs:{id:"_3-jvm的内存区域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-jvm的内存区域"}},[r._v("#")]),r._v(" 3. JVM的内存区域")]),r._v(" "),v("p",[r._v("​\t\tJVM的内存区域分为线程私有区域（程序计数器、虚拟机栈、本地方法区）、线程共享区域（堆、方法区）和直接内存。")]),r._v(" "),v("h3",{attrs:{id:"_4-jvm的运行时内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-jvm的运行时内存"}},[r._v("#")]),r._v(" 4. JVM的运行时内存")]),r._v(" "),v("p",[r._v("​\t\tJVM的运行时内存也叫JVM堆，从GC角度可以将JVM堆分为新生代、老年代、永久代。其中新生代默认占1/3堆空间，老年代默认占2/3堆空间，永久代占非常少的堆空间。新生代又分为Eden区、ServivorFrom区和ServivorTo区，Eden区默认占8/10新生代空间，ServivorFrom区和ServivorTo区分别默认站1/10新生代空间。")]),r._v(" "),v("h4",{attrs:{id:"_4-1-新生代-eden区、servivorto区和servivorfrom区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-新生代-eden区、servivorto区和servivorfrom区"}},[r._v("#")]),r._v(" 4.1 新生代：Eden区、ServivorTo区和ServivorFrom区")]),r._v(" "),v("p",[r._v("​\t\tJVM新创建的对象（除了大对象外）会被存放在新生代，默认占1/3堆内存空间。由于JVM会频繁创建对象，所有新生代会频繁触发MinorGC进行垃圾回收。新生代又分为Eden区、ServivorTo区和ServivorFrom区。")]),r._v(" "),v("p",[r._v("​\t\t（1）Eden区：Java新创建的对象首先会被存储在Eden区，如果新创建的对象属于大对象，则直接将其分配到老年代。大对象的定义和具体的JVM版本、堆大小和垃圾回收策略有关，一般为2KB-128KB，可通过XX:PretnureSizeThreshold设置其大小。在Eden区的内存空间不足时会触发MinorGC，对新生代进行一次垃圾回收。")]),r._v(" "),v("p",[r._v("​\t\t（2）ServivorTo区：保留上一次MinorGC时的幸存者。")]),r._v(" "),v("p",[r._v("​\t\t（3）ServivorFrom区：将上一次MinorGC的幸存者作为这一次MinorGC的被扫描者。")]),r._v(" "),v("p",[r._v("​\t\t新生代的GC过程叫做MinorGC，采用复制算法实现，具体过程如下。")]),r._v(" "),v("p",[r._v("​\t\t（1）把在Eden区和ServivorFrom区中存活的对象复制到ServivorTo区。如果某对象的年龄达到老年代的标准（对象晋升老年代的标准由XX:MaxTenuringThreshold设置，默认15），则将其复制到老年代，同时把这些对象的年龄都加1；如果ServivorTo区的内存空间不够，则也直接将其复制到老年代；如果对象属于大对象（大小为2KB-128KB的对象属于大对象，例如通过（XX:PretenureSizeThreshold=2097152设置大对象为2MB，1024 X 1024 X 2Byte = 2097152Byte=2MB），则也直接将其复制到老年代。")]),r._v(" "),v("p",[r._v("​\t\t（2）清空Eden区和ServivorFrom区中的对象。")]),r._v(" "),v("p",[r._v("​\t\t（3）将ServivorTo区和ServivorFrom区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。")]),r._v(" "),v("h4",{attrs:{id:"_4-2-老年代"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-老年代"}},[r._v("#")]),r._v(" 4.2 老年代")]),r._v(" "),v("p",[r._v("​\t\t老年代主要存放有长生命周期的对象和大对象。老年代的GC过程叫做MajorGC。在老年代，对象比较稳定，MajorGC不会被频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，在MinorGC过仍然出现老年代空间不足或无法找到足够大的连续空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放内存空间。")]),r._v(" "),v("p",[r._v("​\t\tMajorGC采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。")]),r._v(" "),v("p",[r._v("​\t\t因为要先扫描老年代的所有对象再回收，所以MajorGC的耗时较长。MajorGC的标记清除算法容易产生内存碎片，在老年代没有内存空间可分配时，会抛出Out of Memory异常。")]),r._v(" "),v("h4",{attrs:{id:"_4-3-永久代"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-永久代"}},[r._v("#")]),r._v(" 4.3 永久代")]),r._v(" "),v("p",[r._v("​\t\t永久代指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在类加载时会被放入永久代。永久代和老年代、新生代不同，GC不会在程序运行期间对永久代的内存进行清理，这也导致永久代的内存会随着加载的Class文件的增加而增加，在加载的Class文件过多时会抛出Out Of Memory异常，比如Tomcat引用jar文件过多导致JVM内存不足而无法启动。")]),r._v(" "),v("p",[r._v("​\t\t需要注意的是，在Java 8中永久代已经被元数据区（也叫做元空间）取代。元数据区的作用和永久代类似，二者最大的区别在于：元数据区并没有使用虚拟机的内存，而是直接使用操作系统的本地内存。因此，元空间的大小不受JVM内存的限制，只和操作系统的内存有关。")]),r._v(" "),v("p",[r._v("​\t\t在Java 8中，JVM将类的元数据放入本地内存（Native Memory）中，将常量池和类的静态变量放入Java堆中，这样JVM能够加载多少元数据信息将不再由JVM的最大可用内存（MaxPermSize）空间决定，而由操作系统的实际可用内存空间决定。")]),r._v(" "),v("h3",{attrs:{id:"_5-垃圾回收与算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-垃圾回收与算法"}},[r._v("#")]),r._v(" 5. 垃圾回收与算法")]),r._v(" "),v("h4",{attrs:{id:"_5-1-如何确定垃圾"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-如何确定垃圾"}},[r._v("#")]),r._v(" 5.1 如何确定垃圾")]),r._v(" "),v("p",[r._v("​\t\tJava采用"),v("code",[r._v("引用计数法")]),r._v("和"),v("code",[r._v("可达性分析")]),r._v("来确定对象是否应该被回收的，其中引用计数法容易产生循环引用的问题，可达性分析是通过根搜索算法来实现的。根搜索算法是以GC Roots的点作为起点向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡。根搜索算法主要是对栈、方法区中的静态引用、JNI中的引用展开分析。")]),r._v(" "),v("h6",{attrs:{id:"_1-引用计数法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用计数法"}},[r._v("#")]),r._v(" 1. 引用计数法")]),r._v(" "),v("p",[r._v("​\t\t在Java中如果需要操作对象，就必须先获得该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为对象添加一个引用时，引用计数加1；在为对象删除一个引用时，引用计数减1；如果一个对象的引用计数为0，则表示该对象没有被引用，可以被回收。")]),r._v(" "),v("p",[r._v("​\t\t引用计数法容易产生循环引用的问题。循环引用指两个对象互相引用，导致它们的引用一直存在，而不能回收。如下图所示，Object1和Object2互为引用，如果采用引用计数法，则Object1和Object2由于互相引用，其引用计数一直为1，因而无法被回收。")]),r._v(" "),v("h6",{attrs:{id:"_2-可达性分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-可达性分析"}},[r._v("#")]),r._v(" 2. 可达性分析")]),r._v(" "),v("p",[r._v("​\t\t为了解决引用计数法的循环引用的问题，Java还采用可达性分析来判断对象是否可以被回收。具体做法是首先定义一些GC Roots对象，然后以执行GC Roots对象作为起点向下搜索，如果在GC roots和一个对象之间没有可达路径，则称该对象不可达。不可达对象要经过至少两次标记才能判定其是否可以被回收，如果在两次标记后该对象仍然是不可达的，则将被垃圾收集器回收。")]),r._v(" "),v("h4",{attrs:{id:"_5-2-java中常用的垃圾回收算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-java中常用的垃圾回收算法"}},[r._v("#")]),r._v(" 5.2 Java中常用的垃圾回收算法")]),r._v(" "),v("h6",{attrs:{id:"_1-标记清除算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-标记清除算法"}},[r._v("#")]),r._v(" 1. 标记清除算法")]),r._v(" "),v("p",[r._v("​\t\t标记清除算法是基础的垃圾回收算法，其过程分为标记和清除两个阶段。在标记阶段标记所有需要回收的对象，在清除阶段清除可回收的对象并释放其所占用的内存空间。")]),r._v(" "),v("p",[r._v("​\t\t由于标记清除算法在清理对象所占用的内存空间后并没有重新整理可用的内存空间，因此如果内存中可被回收的小对象居多，则会引起内存碎片化的问题，继而引起大对象无法获得连续可用空间的问题。")]),r._v(" "),v("h6",{attrs:{id:"_2-复制算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-复制算法"}},[r._v("#")]),r._v(" 2. 复制算法")]),r._v(" "),v("p",[r._v("​\t\t复制算法是为了解决标记清除算法内存碎片化的问题而设计的。复制算法首先将内存划分为两块大小相等的内存区域，即区域1和区域2，新生成的对象都被存放在区域1中，在区域1中的对象存储满后会对区域1进行一次标记，并将标记后仍然存活的对象全部复制到区域2中，这是区域1将不存在任何存活的对象，直接清理整个区域1的内存即可。")]),r._v(" "),v("p",[r._v("​\t\t复制算法的内存清理效率高且易于实现，但由于同一时刻只有一个内存区域可用，即可用的内存空间被压缩到一半，因此存在大量的内存浪费。同时，在系统中有大量长时间存活的对象是，这些对象将在内存1和内存区域2之间来回复制而影响系统的运行效率。因此，该算法只在对象为“朝生夕死”状态时运行效率较高。")]),r._v(" "),v("h6",{attrs:{id:"_3-标记整理算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-标记整理算法"}},[r._v("#")]),r._v(" 3. 标记整理算法")]),r._v(" "),v("p",[r._v("​\t\t标记整理算法结合了标记清除算法和复制算法的优点，其标记阶段和标记清除算法的标记阶段相同，在标记完成后将存活的对象移到内存的另一端，然后清除该段的对象并释放内存。")]),r._v(" "),v("h6",{attrs:{id:"_4-分代收集算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-分代收集算法"}},[r._v("#")]),r._v(" 4. 分代收集算法")]),r._v(" "),v("p",[r._v("​\t\t无论是标记清除算法、复制算法还是标记整理算法，都无法对所有类型（长生命周期、短生命周期、大对象、小对象）的对象都进行垃圾回收。因此，针对不同的对象类型，JVM采用了不同的垃圾回收算法，该算法被称为分代收集算法。")]),r._v(" "),v("p",[r._v("​\t\t分代收集算法根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为老年代和新生代。新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，在每次进行垃圾回收时都有大量的对象被回收；老年代主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。因此，JVM根据不同的区域对象的特点选择了不同的算法。")]),r._v(" "),v("p",[r._v("​\t\t目前，大部分JVM在新生代都采用了复制算法，因为在新生代中每次进行垃圾回收时都有大量的被回收，需要复制的对象（存活的对象）较少，不存在大量的对象在内存中被来回复制的问题，因此采用复制算法能安全、高效的回收新生代大量的短生命周期的对象并释放内存。")]),r._v(" "),v("p",[r._v("​\t\tJVM将新生代进一步划分为一块较大的Eden区和两块较小的Servivor去区，Servivor区又分为ServivorFrom区和ServivorTo区。JVM在运行过程中主要使用Eden区和ServivorFrom区，进行垃圾回收时会将Eden区和ServivorFrom区中存活的对象复制到ServivorTo区，然后清理Eden区和ServivorFrom区的内存空间。")]),r._v(" "),v("p",[r._v("​\t\t老年代主要存放生命周期较长的对象和大对象，因而每次只有少量分存活的对象被回收，因而在老年代采用标记清除算法。")]),r._v(" "),v("p",[r._v("​\t\t在JVM中含有一个区域，即方法区的永久代，永久代用来存储Class类、常量、方法描述等。在永久代主要回收废弃的常量和无用的类。")]),r._v(" "),v("p",[r._v("​\t\tJVM内存中的对象主要被分配代新生代的Eden区和ServivorFrom区，在少量情况下回被直接分配代老年代。在新生代的Eden区和ServivorFrom区的内存不足会触发一次GC，该过程被称为MinorGC。在MinorGC后，在Eden区和ServivorFrom区中存活的对象会被复制到ServivorTo区，然后Eden区和ServivorFrom区被清理。如果此时在ServivorTo去无法找到连续的内存空间存储某个对象，则将这个对象直接存储到老年代。若Servivor区的对象经历一次CG仍然存活，则其年龄加1。在默认情况下，对象在年龄达到15施，将被移到老年代。")]),r._v(" "),v("h3",{attrs:{id:"_6-java中的4中引用类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-java中的4中引用类型"}},[r._v("#")]),r._v(" 6. Java中的4中引用类型")]),r._v(" "),v("h3",{attrs:{id:"_7-分代收集算法和分区收集算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-分代收集算法和分区收集算法"}},[r._v("#")]),r._v(" 7. 分代收集算法和分区收集算法")]),r._v(" "),v("h3",{attrs:{id:"_8-垃圾收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-垃圾收集器"}},[r._v("#")]),r._v(" 8. 垃圾收集器")]),r._v(" "),v("p",[r._v("​\t\tJava堆内存分为新生代和老年代：新生代主要用来存放短生命周期对象，适合使用复制算法进行垃圾回收；老年代主要存储长生命周期对象，适合使用标记整理算法进行垃圾回收。因此，JVM针对新生代和老年代分别提供了多种不同的垃圾收集器，针对新生代提供的垃圾收集器有Serial、ParNew、Paraller Scavenge，针对老年代提供的垃圾收集器有Serial Old、Parallel Old、CMS，还有针对不同区域的G1分区收集算法。")]),r._v(" "),v("h4",{attrs:{id:"_8-1-serial垃圾收集器-单线程-复制算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-serial垃圾收集器-单线程-复制算法"}},[r._v("#")]),r._v(" 8.1 Serial垃圾收集器：单线程，复制算法")]),r._v(" "),v("p",[r._v("​\t\tSerial垃圾回收器基于复制算法实现，它是一个单线程的收集器，在它进行垃圾回收时，必须暂定其他所有工作线程，直到垃圾收集结束。")]),r._v(" "),v("p",[r._v("​\t\tSerial垃圾收集器采用了复制算法，简单、高效，对于单CPU运行环境来说，没有线程交互开销，可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器是Java虚拟机运行在Client模式下的新生代的默认垃圾收集器。")])])}),[],!1,null,null,null);t.default=_.exports}}]);