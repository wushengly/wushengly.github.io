(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{639:function(t,a,s){"use strict";s.r(a);var r=s(5),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("介绍")]),s("p",[t._v("Java中的锁")])]),s("p",[t._v("​\t\tJava中的锁主要用于保障多并发线程情况下数据的一致性。在多线程")]),t._v(" "),s("h3",{attrs:{id:"_14-什么是cas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-什么是cas"}},[t._v("#")]),t._v(" "),s("strong",[t._v("14. 什么是CAS")])]),t._v(" "),s("h4",{attrs:{id:"_14-1-cas的概念-比较并交换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-cas的概念-比较并交换"}},[t._v("#")]),t._v(" "),s("strong",[t._v("14.1 CAS的概念：比较并交换")])]),t._v(" "),s("p",[t._v("​\t\tCAS（Compare And Swap）指比较并交换。CAS算法CAS（V,E,N）包含3个参数，V表示要更新的变量，E表示预期的值，N表示新值。在且仅在V值等于E值时，才会将V值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，当前线程什么都不做。最后，CAS返回当前V的真实值。")]),t._v(" "),s("h4",{attrs:{id:"_14-2-cas的特性-乐观锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-cas的特性-乐观锁"}},[t._v("#")]),t._v(" "),s("strong",[t._v("14.2 CAS的特性：乐观锁")])]),t._v(" "),s("p",[t._v("​\t\tCAS操作采用了乐观锁的思想，总是认为自己可以成功完成操作。在有多个线程同时使用CAS操作一个变量时，只有一个会胜出并成功更新，其余均会失败。失败的线程不会被挂起，仅被告知失败，并且允许再次尝试，当然，也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当处理。")]),t._v(" "),s("h4",{attrs:{id:"_14-3-cas自旋"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-cas自旋"}},[t._v("#")]),t._v(" "),s("strong",[t._v("14.3 CAS自旋")])]),t._v(" "),s("h3",{attrs:{id:"_16-什么是aqs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-什么是aqs"}},[t._v("#")]),t._v(" "),s("strong",[t._v("16. 什么是AQS")])]),t._v(" "),s("p",[t._v("​\t\tAQS（Abstract Queued Synchronizer）是一个抽象的队列同步器，通过维护一个共享资源状态（）")])])}),[],!1,null,null,null);a.default=_.exports}}]);