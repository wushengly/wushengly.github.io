(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{637:function(a,t,v){"use strict";v.r(t);var _=v(5),e=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"title"}),v("p",[a._v("Java自定义注解的用法")])]),v("h2",{attrs:{id:"java自定义注解的用法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java自定义注解的用法"}},[a._v("#")]),a._v(" Java自定义注解的用法")]),a._v(" "),v("h3",{attrs:{id:"_1-java注解介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-java注解介绍"}},[a._v("#")]),a._v(" 1.  Java注解介绍")]),a._v(" "),v("p",[a._v("Java 注解（Annotation）又称 "),v("code",[a._v("Java 标注")]),a._v("，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。")]),a._v(" "),v("h3",{attrs:{id:"_2-内置注解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-内置注解"}},[a._v("#")]),a._v(" 2.  内置注解")]),a._v(" "),v("p",[a._v("Java定义了一套注解，共有7个，3个在java.lang包下，剩下4个在java.lang.annotation中。")]),a._v(" "),v("p",[v("code",[a._v("作用在代码的注解：")])]),a._v(" "),v("ul",[v("li",[a._v("@Override : 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。")]),a._v(" "),v("li",[a._v("@Deprecated : 标记过时的方法。如果使用该方法，会报编译异常。")]),a._v(" "),v("li",[a._v("@SuppressWarnings : 指示编译器去忽略注解中声明的警告。")])]),a._v(" "),v("p",[v("code",[a._v("作用在其他注解上的注解（元注解）：")])]),a._v(" "),v("ul",[v("li",[a._v("@Retention : 标识这个注解如何保存。")]),a._v(" "),v("li",[a._v("@Documented : 标记这些注解是否保存在用户文档中。")]),a._v(" "),v("li",[a._v("@Target : 标记这个注解应该是哪种 Java 成员。")]),a._v(" "),v("li",[a._v("@Inherited : 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)")])]),a._v(" "),v("h3",{attrs:{id:"_3-内置注解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-内置注解"}},[a._v("#")]),a._v(" 3.  内置注解")]),a._v(" "),v("p",[a._v("Java定义了一套注解，共有7个，3个在java.lang包下，剩下4个在java.lang.annotation中。")])])}),[],!1,null,null,null);t.default=e.exports}}]);